# 20210601 

## Facts

* 패스트 캠퍼스 자료구조 : 삽입 정렬, 재귀 용법, 동적계획과 분할 정복에 대해서 공부했습니다. 
* 이진 탐색 트리 자료구조를 구현했습니다. 
  * 데이터 삭제 기능을 구현했습니다. 
* 리얼 월드 HTTP 2장을 읽고 정리했습니다. 
* 고양시 취업 사관 학교 사전 설명회를 참석했습니다. 

## Feelings

* 6월 시작 TIL을 작성할 수 있어서 기분이 좋습니다. 출발이 좋은 것 같습니다. 
* 이전에는 타자 치는 양이 적어 느끼지 못했었는데 키보드에 문제가 있는 것 같습니다. 자꾸 중복으로 눌리는 문제가 발생해서 불편합니다. 
* 리얼월드 http를 읽으면서 예전에 읽었던 http관련 도서를 복습하는 기분입니다. 잘 읽고 추가적으로 정리를 열심히 해야겠습니다. 

## Findings

* [리얼월드 http 2장 정리](https://github.com/hyejineee/Reading-and-Writing/blob/master/%EC%A0%95%EB%A6%AC/%EB%A6%AC%EC%96%BC%EC%9B%94%EB%93%9C%20http.md#2%EC%9E%A5-http10%EC%9D%98-%EC%8B%9C%EB%A7%A8%ED%8B%B1%EC%8A%A4--%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B8%B0%EB%8A%A5%EC%9D%98-%EC%9D%B4%EB%A9%B4) 

* 알고리즘 : 삽입 정렬, 재귀 용법, 동적 계획과 분할 정복

  * 삽입 정렬 : 

    * 특정 데이터를 삽입하여 정렬

      1. 두 번째 인덱스 부터 시작

      2. 해당 인텍스(key값) 앞에 있는 데이터(B)부터 비교해서 key 값이 더 작으면, B값을  뒤 인덱스로 복사 

      3. 위의 내용을 key 값이 더 큰 데이터를 만날 때까지 반복, 큰 데이터를 만난 위치 바로 뒤에 key값을 이동

      ```kotlin
      val data = mutableListOf(5, 3, 2, 4)
      
      for (i in 1 until data.size) {
        for (j in i downTo 1) {
          if (data[j] < data[j - 1]) {
            data.also {
              val temp = it[j]
              it[j] = it[j - 1]
              it[j - 1] = temp
            }
          } else {
            continue
          }
        }
      }
      
      ```

  * 재귀 용법:

    * 함수 안에서 함수를 호출하는 형태 
    * 재귀 호출은 스택의 전형적인 예 : 함수는 내부적으로 스택처럼 관리된다.

  * 동적 계획과 분할 정복 :

    * 동적 계획법 : 
      * 입력 크기가 작은 문제들을 해결한 후, 해당 문제의 해를 활용하여 보다 큰 크기의 부분 문제를 해결. 최종적으로 전체 문제를 해결하는 알고리즘. 
      * 상향식 접근법 
    * 분할 정복 :
      * 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘.
      * 하향식 접근법
    * 공통점 :
      * 문제를 잘게 쪼개서, 가장 작은 단위로 분할한다.
    * 차이점 : 
      * 동적 계획법 
        * 부분 문제는 중복되어, 상위 문제 해결 시 재활용된다.
        * 메모이제이션 기법을 사용한다.
      * 분할 정복
        * 부분 문제는 서로 중보되지 않는다.
        * 메모이제이션 기법을 사용하지 않는다.

## Future Action Plans

- 자료구조, 알고리즘 문제를 슬슬 풀도록 해야겠습니다.
- 지금까지 배웠던 자료구조, 알고리즘 이론을 복습해야겠습니다.

