# 테스트 주도 개발로 배우는 객체 지향 설계와 실천

## 1장 테스트 주도 개발의 핵심은 무엇인가?

###   TDD를 왜 해야 할까?

- 시스템 규모를 믿을 수 있는 방식으로 키우고, 예상치 못한 변화에 대처하기 위해 필요하다.
- 주기적인 피드백과 점진적인 개발 방식은 프로젝트와 관련된 사람들이 무엇을 달성해야 하는지 이애하고 그 과정에서 잘못 이해하고 있는 바를 식별하게 한다. 
  - 피드백
    - 가정을 갖고 작성한 코드에 대한 검사할 수 있는 기회 
    - 피드백 주기 -> 고리형 시스템 : 중첩된 고리 형태 안에서 피드백은 어디서나 오류, 오해를 포착하고 고칠 수 있는 기회를 만든다.
- TDD에서는 데스트를 설계 활동으로 바꾼다.

### TDD를 통해 얻을 수 있는 것은 무엇인가?

* 시스템 구현 - 시스템이 동작하는가?	
  * 컨텍스트를 선명하게 인지하는 동안 오류를 탐지한다.
* 시스템 설계 - 시스템이 잘 구조화돼 있는가?
  * 다음 작업에 대한 조건을 명확하게 알 수 있다.
  * 느슨하게 결합된 구성 요소를 작성할 수 있게 된다.
  * 코드가 하는 일에 대한 실행 가능한 설명이 더해진다. 
  * 완전한 회귀 스위트가 늘어난다.
  * 언제 작업이 충분히 완료 됐는지 알게 되어 과도한 최적화를 하거나 불필요한 기능을 더하지 않게 된다. 
* 외부 품질 유지 : 시스템이 고객과 사용자의 요구를 얼마나 잘 충족하는가 
* 내부 품질 유지 : 시스템이 개발자와 관리자의 요구를 얼마나 잘 충족하는가 -> 시스템 동작 방식을 안전하고 예상 가능한 상태로 바꿀 수 있게함

### TDD 황금률

> 실패하는 테스트 없이는 새 기능을 작성하지 말라.

### 리팩터링이란 무엇인가?

> 기존 코드의 작동 방식을 바꾸지 않은 채로 기존 코드의 내부 구조를 변경하는 것이다.
>
> 리팩터링의 핵심은 코드가 구현하는 기능의 표현을 개선해 코드를 좀 더 유지 보수할 수 있게 만드는 것이다.

* 리팩터링의 범위는 이해하기 쉽고 안전할 정도로 규모가 작아야 한다.

### 통합 테스트, 인수테스트란 무엇인가?

* 통합 테스트 
  * 변경할 수 없는 코드를 대상으로 코드가 동작하는가?
  * 일부 코드가 변경할 수 없는 팀 바깥의 코드를 어떻게 이용할지 검사하는 테스트 
  * 서드 파티 코드를 대상으로 만든 추상화가 기대한 대로 동작하는지 확인하기 위한 테스트 
* 인수 테스트
  * 프로젝트를 이끌어 가는 테스트 
  * 만들고자 하는 기능을 시험하는 테스트 
  * 전체 시스템이 동작하는가?
  * 전 구간 테스트 
    * 시스템 내부 코드를 가능한 한 직접 호출하지 말고 외부에서 유입되는 시스템과 상호작용하는 테스트
    * 시스템과 해당 시스템을 구축하고 배포하는 프로세스를 모두 시험

---

스터디 내용 

- 시스템을 개발하면서 만날 수 있는 어려움. 
  - 예측한 것과 실제가 다른것 
  - 예상하지 못한 변경
- 변화에 대처하기 위해 위해서는 우리가 어떤 기술적인 토대가 필요한가?
  - 테스트와 깨끗한 코드 
  - 왜?
    - 테스트를 작성하는 것은 잘 구조화된 코드를 생성한다.
    - 잘 구조화 된 코드는 깨끗한 코드와 관련이 있다. 
    - 테스트를 작성하는 것은 설계 활동이다.

---

## 2장 객체를 활용한 테스트 주도 개발 
### 객체지향이란 무엇인가?

* 하나의 책임을 수행하기 위해 각자 역할을 가지고 자율적으로 동작하는 객체들이 서로 협력하는 방식으로 프로그래밍 하는 것.
* 객체 지향 시스템 
  * 협업하는 객체의 망으로 구성
  * 시스템은 객체를 생성해 서로 메시지를 주고받을 수 있게 조립하는 과정을 거쳐 만들어진다.
* 객체 
  * 자신이 이해할 수 있는 메시지를 처리 
  * 내부 상태를 캡슐화 
  * 자율적으로 메시지를 처리 

### 값과 객체는 무엇이고, 어떤 차이점이 있는가?

* 값 
  * 변하지 않는 양이나 크기를 나타낸다.
  * 불변적
* 객체 
  * 시간이 지남에 따라 상태가 변한다. -> 시간의 추이에 따른 객체의 행위를 나타낸다.
  * 식별자가 있다.
  * 계산 절차를 담고 있다.
  * 가변적

### 메시지란 무엇인가?

* 다른 객체와 의사소통할 수 있는 수단
* 객체간의 의존성을 명시적으로 나타내는 것 
* 객체간의 의사소통(메시지)에 초첨을 맞추어 설계를 이끌어 나가야 한다. 
  * 왜 메시지 중심으로 설계를 이끌어 나가야 하는가?
    * 메시지 = 객체가 다른 객체에 접근할 수 있는 유일한 방법이다.
    * 메시지 = 메시지를 받은 객체가 수행해야 하는 책임을 의미한다.
    * 책임 = 객체가 무엇을 해야하는가? 를 설명한다.
    * 메시지에 초점을 맞춘다. = 객체가 무엇을 하는가에 초점을 맞춘다. 
    * 어떻게 하는가에 대해서는 객체가 자율적으로 선택하게 한다.
    * 시스템의 행위를 변경하기 쉽게 하여 시스템이 유연하도록 만든다.

### 디미터 법칙

* 디미터의 법칙 
  * 객체는 자기 자신을 책임지는 자율적인 존재여야 한다.
  * 객체는 내부적으로 보유하고 있거나 메시지를 통해 확보한 정보만 가지고 의사 결정을 내려야 한다.
  * 객체는 다른 객체를 탐색해 뭔가를 일어나게 해서는 안된다.

### mock 객체란 무엇인가?

* 테스트 대상이 되는 객체의 이웃을 대체하는 가짜 객체 
* 목 객체를 사용하면 객체 간의 관계를 파악하는 데에 도움이 된다.

### 테스트에서 목 객체를 어떻게 사용하는가?

1. 테스트 대상 객체의 이웃 객체를 목 인스턴스로 생성
2. 해당 목 인스턴스를 어떻게 호출하고 상태를 검사하는가에 관한 예상 구문 결정
3. 테스트시 스텁 형태로 동작할 필요가 있는 행위를 구현 

* 목 객체의 사용으로 단위 테스트는 대상 객체와 해당 객체를 둘러싼 환경 간의 관계를 명확하게 드러나게 만든다.

---

스터디 

* 메소드 체이닝과 열차 충돌의 차이 
  * 메소드 체이닝은 내부 구현이 들어나지 않지만 열차 충돌은 내부 구현 (세부 사항)을 드러낸다.

---

## 3장 도구 소개 

책 참고.

## 4장 테스트 주도 주기 시작

### 최초 기능의 역설

* 도구를 마련하고 동시에 마련한 도구로 테스트를 하면서 기능까지 구현하기 어려움 -> 안정적이지 못한 개발 환경
* 해결 : 2가지 문제로 쪼개기
  1. 동작하는 골격을 대상으로 빌드, 배포, 테스트하는 방법 파악
  2. 기반 구조(동작하는 골격)을 이용해 유의미한 첫 기능에 대한 인수 테스트 작성 

### 동작하는 골격이란 무엇인가?

* 전 구간을 대상으로 자동 빌드, 배포, 테스트를 할 수 있는 실제 기능을 가장 얇게 구현한 조각
* 빌드, 배포, 테스트를 나중으로 미루는 것은 위험하다.
* 프로젝트가 올바른 방향으로 나아가고 있는지 최대한 미리 파악해야 한다.
* 동작하는 골격 개발 = 애플리케이션의 개괄적인 구조를 결정하기 시작 
  * 초기 구조 설계하려면 시스템의 목적을 이해해야 한다.
  * 팀에서 자신들의 해법을 전체적으로 조망하는 데 이바지하게 끔 첫 테스트를 작성하는 과정을 활용해 프로젝트의 맥락을 짚어내는 것 

### 동작하는 골격을 먼저 만들어야 하는 이유는 무엇인가?
* 동작하는 골격은 프로젝트 초기에 각종 쟁점을 드러낸다.
* 불확실한 것을 먼저 발견하는 것이 중요하기 때문이다.
* 점진적 개발 = 프로젝트 초에는 불안정한 상태로 시작하지만 일부 기능을 구현하고 프로젝트 자동화가 구축되고 나면 반복적인 과정으로 안정화된다.
* 동작하는 골격 만들기 = 알아서 굴러가게 만들기 

----

스터디 

* 칠판에 간략하게 그리는 것 
  * 배포는 뭐로 할끼? aws로 할까? 
  * 자동화는?? 트래비스로 할까 github action을 쓸까??
* 동작하는 골격 = CI /CD까지 
* 가장 얇게 구현한 기능 = 리액트 기본 구조까지만 적는거??
* 지도앱을 만든다 -> 어떤 지도를 사용하는 지에 대해 기본만 구현하는 것 까지 동작하는 골격에 포함
* 지도에 대한 의존성을 분리하는 것은 프로젝트를 진행하면서 리팩터링 해 프로젝트를 진행시킬 것 

----

## 5장 테스트 주도 개발 주기의 유지 
1. 각 기능을 인수 테스트로 시작하라.

   * 인수 테스트를 작성하는 것으로 신기능을 작업 하는 데 착수 
   * 그 기능이 완성 되기 까지 진행 상황을 반영한다. -> 프로젝트를 나아가게 함.

2. 회귀를 포착하는 테스트와 진행 상황을 추적하는 테스트를 분리하라.

   * 인수 테스트 통과 주기 : 중첩된 프로젝트 피드백 고리를 구동하는 엔진

   * 회귀를 포착하는 테스트 : 기존 코드의 망가짐을 확인하는 것 (?)
   * 진행 상황을 측정하는 테스트 : 새로운 인수테스트 (?)

3. 테스트를 가장 간단한 성공 케이스로 시작하라.

   * 시스템에 가치를 더하고 아이디어의 유효성에 관해 충분한 피드백을 주는 테스트 케이스를 작성하라.

4. 읽고 싶어할 테스트를 작성하라.

   * 가능한한 명확하게 표현해야 한다.
   * 잘 읽히는 테스트 -> 테스트를 그 다음으로 지원하는 기반 구조를 만든다.

5. 테스트가 실패하는 것을 지켜보라.

   * 오류 메시지를 검사해야 하는 이유 
     * 현재 작업중인 코드에 대한 가정을 확인하기 위해 
     * 테스트와 실패 메시지는 코드가 의도( 무엇을 해야 하는지 )를 강조하는 표현이기 떄문이다. -> 신뢰성있고 유지하기 쉬운 시스템을 개발하는 데 필수 

6. 입력에서 출력 순서로 개발하라.

   * 기능 개발을 시작할 때 가장 먼저 시스템이 새로운 행위를 일으키게 하는 이벤트를 고려함.
   * 외부 이벤트를 받는 객체 -> 중간 계층 -> 중심 도메인 

7. 메서드가 아닌 행위를 단위 테스트하라.

   * 행위 = 테스트의 목적을 알려주기 때문
   * 테스트 -> 무엇을 테스트 하는가, 왜 테스트 하는가가 중요
   * 테스트 이름 짓기 
     * 객체의 책임이 무엇인가 
     * 객체의 여러 메서드가 어떻게 함께 동작하는지 

8. 테스트에 귀를 귀울이라.

   * 테스트하기 어려운 기능 발견 -> 스스로에게 묻기
     * 기능을 어떻게 테스트할 것인가 
     * 왜 테스트하기 어려운가 
   * 테스트하기 어렵다. -> 설계 개선이 필요하다.

> TDD의 테스트 부분에서 얻을 수 있는 최고의 혜택은 코드를 망가뜨리지 않고도 변경할 수 있다는 자신감이다. 진행을 막는 것은 바로 두려움이다.

## 6장 객체 지향 스타일

### 포드 어댑터 아키텍처란 무엇인가?

* 비즈니스 도메인의 코드가 데이터베이스나 사용자 인터페이스 같은 기술 기반 구조의 의존성과 격리된 아키텍처
  * 포트 : 인터페이스를 작성해 애플리케이션 모델과 외부 세계의 관계를 애플리케이션 모델의 용어로 기술 
  * 어댑터 (손상 방지 계층) : 애플리케이션의 핵심부와 각 기술 도메인 사이에서 브리지 역할을 하는 코드 
    * 애플리케이션 모델에서 정의한 인터페이스를 구현하고 애플리케이션 수준의 객체와 기술 수준의 객체를 매핑한다.
* 관심사의 분리 : 시스템의 동작 방식을 변경할 경우, 되도록 적은 양의 코드를 변경 하고자 함. -> 변경 이유가 같은 코드끼리 모은다.
* 더 높은 수준의 추상화 : 복잡성을 다루는 방법. 유용한 기능 컴포넌트를 조합하는 식으로 프로그램 작성.

### 캡슐화와 정보 은닉

[객체지향의 올바른 이해 : 정보 은닉](https://effectiveprogramming.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%A0%95%EB%B3%B4-%EC%9D%80%EB%8B%89information-hiding%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%9D%B4%ED%95%B4)

[정보은닉](http://egloos.zum.com/aeternum/v/1232020)

* 캡슐화 : 객체의 행위가 해당 객체의 API를 통해서만 좌우될 수 있음을 보장
  * 데이터를 공용 메서드를 통해서만 접근하도록 어용하는 방법
* 정보 은닉 : 객체가 해당 객체의 기능을 구현하는 방법을 추상화된 API 너머로 감추는 것
  * 모듈( 책임의 할당 )을 분할하기 위한 기본 원리 
  * 복잡하고 변경 가능한 설계 결정을 안정적인 인터페이스 뒤로 숨기는 기본 설계 원리
  * 코드가 구체적인 것에 의존하는 것을 막음으로써 변경에 대한 유연성을 제공하는 것 

* 시스템을 구성할 때는 각 객체의 안팎으로 무엇을 둘지 결정해 해당 객체가 명확한 API와 함께 응집력 있는 추상화를 제공하게 해야 한다.
  * API를 통해 해당 객체의 내부에 접근하는 것을 캡슐화하고, 세부 사항을 시스템의 나머지 부분으로부터 감추는 것 

### 단일 책임 원칙

* 특정 객체에게 어울리는 기능을 선택하기 위한 기준(?)
* 모든 객체는 반드시 단 한 가지 명확히 규정된 책임을 지녀야 한다.
  * 객체의 역할을 한 절로 설명.
* 여러 객체를 조합해 새로운 추상화를 만드는 데도 적용 
  * 여러 객체에 걸쳐 구현된 행위를 단일 구성물로 뭉뚱그릴 경우 해당 구성물의 역할을 명확하게 설명할 수 있어야 한다.
  * 전체는 부분의 합보다 단순해야 한다.
  * 컨텍스트 독립성

### 전체는 부분의 합보다 단순해야 한다. 의 의미는 무엇인가?

* 복합 객체의 API는 반드시 구성 요소의 존재와 구성 요소 간의 상호 작용을 감추고 더 단순한 추상화를 이웃에게 드러내야 한다.
* 코드 규모가 커짐에 따라 추상화 수준을 높일 수 있는 규칙이 된다.

### 컨텍스트 독립성이란 무엇인가?

* 컨텍스트 독립적 : 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다.
  * 컨텍스트 독립성 : 한 객체가 정보를 너무 많이 감췄거나 잘못된 정보를 감췄는지 판단하는 데 유용하다.
* 컨테스트에 대해 독립적이다. 컨텍스트에 대한 정보가 적다 -> 객체가 다양한 컨텍스트에서 재사용 될 수 있다
* ❓❓❓❓예시 

## 7장 객체 지향 설계의 달성

### 테스트 작성은 설계에 어떻게 도움이 되는가?

1. 어떻게를 고려하기 전에 달성하고자 하는 바가 무엇인지를 기술하게 함
2. 단위 테스트를 이해 가능한 상태로 유지하기 위해 단위 테스트의 범위를 제한함
3. 의존성의 위치(의존성이 있는 객체와의 관계(?))를 알게 함
   *  단위 테스트를 위한 객체를 만들려면 해당 객체의 의존성을 전달해야 함

### 값 타입을 사용하는데 이점은 무엇인가?

1. 구체적인 타입의 사용으로 혼동을 피할 수 있다.
2. 값의 개념을 나타내는 타입을 만들어 두면 행위를 추가하기에 적절한 장소가 되어 좀 더 객체 지향적인 접근법을 사용하는데 도움을 준다.

### 값 타입 객체는 어떻게 만들어지는가?

* 분해 : 큰 객체를 협력 객체의 그룹으로 나누기 

  * 복잡한 객체를 응집력 있는 기능 단위로 작은 협력 객체로 만들어 독립적인 단위 테스트를 작성하게 함

  * 어떤 객체가 손쉽게 테스트할 수 없을 정도로 몸집이 크거나 테스트가 실패한 이유를 해석하기 어렵다면 해당 객체를 분해한다.

* 파생 : 객체가 필요로 하는 신규 서비스 정의와 해당 서비스를 제공하기 위한 새 객체 추가 

  * 객체에 행위를 추가하고 설계 원칙을 따르더라도 어떤 새로운 기능은 원칙에 속하지 않을 수도 있다.

    -> 인터페이스를 만들어 객체 관점에서 필요한 서비스를 정의한다.

  * 주문형 설계 : 어떤 클래스에서 제공 해야 할 기능을 밀어내지 않고 클라이언트의 요구 사항으로부터 인터페이스와 해당 인터페이스의 구현체를 현실로 끄집어내는 것 

* 포장 : 관련 객체를 포함 객체로 감추기 

  * 객체의 테스트가 복잡해서 테스트를 준비할 수 없는 경우
  * 코드를 적절한 상태에 두기엔 유동적인 부분이 많을 경우
  * 전체는 부분의 합보다 단순해야 한다 규칙의 응용
  * 함께 동작하는 관련 객체의 집합이 있을 경우 그것들을 하나로 포함하는 객체로 포장할 수 있다.
    * 기존 집합의 복잡성을 추상화로 감춤
    * 높은 수준에서 프로그래밍할 수 있다.
  * 암시적인 개념을 구체적으로 만드는 과정의 좋은 효과 
    1. 도메인을 좀 더 잘 이해하는 데 도움이 되는 이름을 개념에 부여 
    2. 개념의 경계를 확인할 수 있음 -> 의존성의 범위를 명확하게 한정할 수 있음
    3. 단위 테스트를 정확하게 수행할 수 있음.

### 인터페이스는 언제 리팩토링해야 하는가?

1. 인터페이스 간의 유사점과 차이점에 신경이 쓰이기 시작할 때 -> 비슷한 애들
   * 인터페이스가 단일 개념을 표현하고 있으며, 병합될 수 있는지 살펴야 함
2. 인터페이스를 구현하기 시작할 때

### 구현 계층, 선언 계층은 무엇인가? 왜 분리하는가?

* 구현 계층 : 이 계층에 속하는 객체가 이벤트에 어떻게 반응하는가
  * 코드가 그것을 하려는 일을 어떻게 하는지 기술
* 선언적 계층 : 작은 편의성 메서드와 문법을 이용해 각 부분의 용도를 기술 
  * 코드가 하려는 일이 무엇인지 기술

----

스터디 

무엇 때문에 프로젝트가 난항을 겪고 있는가?

## 20장 테스트에 귀 기울이기

* 코드에 추가하고 싶은 일부 기능에 대한 테스트 작성의 어려움 => 설계를 개선해야 한다.
* 테스트 주도 
  * 기능과 성능처럼 겉으로 드러나는 품질 속성( 클래스의 결합도와 응집력, 명시적이거나 감춰진 의존성, 효과적인 정보 은닉)을 검증하는 활동
  * 객체를 손쉽게 테스트하게 해주는 품질 요소가 코드를 변화에 반응성 있게 만들어 준다.
  * 코드를 유지 보수 가능한 상태로 유지하는 품질 속성에 관한 작업
  * 설계에 관한 신속한 피드백 
  * 테스트하기 어려운 기능 -> 왜 테스트하기 어려운가?

### 테스트 악취

1. 테스트 자체가 제대로 작성되지 않은 경우 : 테스트가 불분명하거나 불안정하게 작성된 경우
2. 세트스에서 대상 코드가 문제라고 강조되는 경우 : 테스트하기 어려운 경우

* 테스트 이름이 그 테스트 케이스가 의도하는 바를 명확히 설명하지 못하며 다른 테스트 케이스와의 차이점도 드러내지 못하는 경우
* 테스트 케이스 하나로 여러 기능을 테스트하는 경우
* 테스트 구조가 서로 달라서 코드를 읽는 사람이 테스트를 쭉 훑어 보는 것만으로는 테스트 의도를 이해할 수 없음.
* 테스트를 준비하고 예외 처리를 하는 코드가 너무 많아서 핵심 로직이 파묻힘
* 리터럴 값(매직넘버)를 사용하지만 해당 값의 정체가 명확하지 않는 테스트 

### 대체할 수 없는 객체에 목 객체 적용

* 전역 구조인 객체에 목 객체 적용 => 예시 : 자바 날짜 라이브러리 
  * 전역 객체를 사용하는 객체가 생성되는 방법을 제어 => clock
* 전역 값을 사용해 캡슐화를 우회함으로써 컴포넌트 호출자로부터 의존성을 감출 수 있지만 그렇게 한다로 해서 의존성이 사라지지는 않으며, 단지 의존성에 접급할 수 없게 될 뿐이다(267p) = 암시적 의존성도 여전히 의존성이다.

### 구상 클래스에 대한 목 객체 적용

* 인터페이스 분리 원칙 : 클라이언트가 사용하지 않는 인터페이스에 의존하게 해서는 안된다.
* 그러나 예외 상황일때는 이 방법을 사용하기도 함
  * 상호 작용 테스트에 대한 접근법 : 인터페이스가 아니라 구상 클래스를 대항으로 목 객체를 적용
* 클래스의 내부 기능을 재정의 해서는 안 된다.(273p)
  * 현재 구현의 유별난 부분에서 테스트가 묶여버림
  * 가시적인 메서드만 재정의해야 한다.

### 값에 목 객체 적용

* 값 객체에 목 객체를 적용할 필요가 없는 이유
  1. 값은 불변적이다.
  2. 해당 타입의 인터페이스를 구현하는 클래스를 대상으로 의미 있는 이름을 생각해낼 수 없다.
* 값 객체의 인스턴스를 생성하기 어려워 목 객체를 적용하고 싶을 경우 -> 빌더를 작성하는 방법 고려

### 비대한 생성자

* 생성자의 인자 목록이 길고 다루기 어려운 경우 
  * 인자 목록으로부터 도출할 수 있는 암시적 구조가 있는지 확인
    *  -> 특정 개념을 나타내는 일부 인자를 묶어 새로운 객체로 대체할 수 있음
    * 암시적인 컴포넌트를 뽑아낼 경우 2가지 조건 살펴보기
      1. 해당 클래스에서 늘 함께 사용되는 수명이 같은 인자가 있는가
      2. 1번 조건에 일치하는 부분에 어울리는 이름은 무엇인가? ( 276p. 조건이 일치하는 부분을 찾고 나면 해당 개념을 설명하는 더 나은 이름을 알아내는 좀 더 어려운 일이 남는다. )
  * 객체에 역할이 너무 많아서 객체 자체의 규모가 너무 크다는 의미 
    * 역할을 분리 
  * 모든 인자가 객체 이웃의 유형에서 의존성이 아닌 경우
    * 알림과 조정 객체는 기본 값을 설정할 수 있고 나중에 재설정이 가능하다.

### 너무 많은 예상 구문

* 테스트에 예상 구문이 너무 많으면 중요한 것이 무엇이고 실제로 무엇을 테스트하는지 파악하기 어렵다,

### 테스트 악취에 귀 기울이기의 이점 (281p ~)

1. 지식의 초점이 특정 객체에 맞춰진다.
   * 테스트 악취의 일부는 컴포넌트 간에 새어 나가는 지식과 관련있다.
   * 지식을 특정 객체에 국한할 수 있다면 해당 객체의 구현은 그것을 둘러싼 콘텍스트에 독립성을 유지할 수 있다.
2. 뭔가가 명시적이라면 거기에 이름을 부여할 수 있다.
   * 구상 클래스를 대상으로 목 객체를 적용하는 것을 좋아하지 않는 한 가지 이유는 여러 객체 간의 관계는 물론 객체 자체에도 이름을 부여하길 좋아하기 때문이다.
3. 이름이 더 많다는 것은 도메인 정보가 더 많다는 의미다.
   * 객체가 어떻게 상호 작용하는지 강조할 경우 구현보다 좀 더 도메인 측면에서 정의된 타입과 역할을 갖게 된다.
   * 자그마한 추상화가 많이 되어 있기 때문
4. 데이터 대신 행위를 전달하라.
   * '묻지 말고 말하라'를 꾸준히 적용하다 보면 스택을 통해 값을 꺼내는 대신 시스템에 행위를 전달하는(콜백 현태로) 경향을 보이는 코딩 스타일이 만들어짐. 
   * 좀 더 정확한 인터페이스는 더 나은 정보 은닉과 더운 명확한 추상화를 가능하게 한다.

* 테스트와 코드를 깔씀하게 유지하는 것 -> 도메인을 이해하고 새로운 요구 사항으로 말미암아 설계를 변경해야 하는 경우에 대처하지 못하는 위험을 줄이는 데 도움이 됨.
* 가독성 있고 유연한 테스트를 작성하는 데 노력을 기울임으로써 테스트하는 코드의 내부 품질에 관한 피드백을 좀 더 얻을 수 있다.
* 이해하기 어려운 테스트 
  * 1000줄 이상의 단위 테스트
  * 많은 픽스처 생성
  * 너무 많은 준비과정 

## 21장 테스트 가독성

테스트 가독성을 향상 시키기 위한 규칙들 

* TDD가 지속 가능하려면 테스트가 코드의 작동 방식을 검증하는 것 이상을 해야만 한다.
* 테스트는 행위를 명확하게 표현하기도 해야 한다. = 테스트의 가독성이 중요한 이유 
* 테스트 코드는 제품에서 하는 일이 무엇인지 반드시 기술해야 한다,
  * 테스트 코드가 예상 되는 결과의 예제로 사용하는 값에 관해서는 구체적이지만 해당 코드가 동작하는 방식에 관해서는 추상적인 경향이 있기 때문.
  * 테스트 코드는 의존성 사슬의 끝에 위치하므로 대상 코드의 의도를 표현하는 것이 다른 객체망의 일부를 구성하는 일보다 중요하다.

### 테스트의 이름은 기능을 기술한다.

* 테스트의 이름은 개발자가 현재 테스트 중인 것이 무엇이고 대상 객체가 어떻게 행동해야 할지에 대한 첫 번째 단서를 제시해야 한다.
  * 다양한 상황에서 객체가 무슨 일을 하고 메서드 용도가 무엇인지 알 필요가 있다.
* 대상 객체에서 제공하는 기능 측면에서 테스트 이름을 짓는 것 
  * Test dox 관례 -> 개발자가 대상 객체가 하는 일을 중심으로 생각하게끔 독려함.

### 정규 테스트 구조

* 테스트를 표준 형태로 작성하면 이해하기 쉽다.
* 테스트를 표준 형태로 작성하기 어렵다 => 코드가 너무 복잡하거나 아이디어를 그다지 명확하게 하지 않았음을 암시 

1. 준비 : 대상 코드가 실행될 환경에 해당하는 테스트의 콘텍스트를 마련한다.
2. 실행 : 대상 코드를 호출해 테스트된 행위를 촉발한다.
3. 검증 : 해당 행위에서 예상할 수 있는 가시적인 효과를 검사한다.
4. 정리 : 다른 테스트에 손상을 입힐 수도 있을 잔존 상태를 정리한다.

### 테스트 코드의 능률화

* 테스트 코드를 비롯해 모든 코드는 '어떻게' 보다 '무엇'을 강조해야 한다.
  * 메서드에 구현 세부 사항이 많이 포함될수록 해당 메서드를 읽는 사람은 무엇이 중요한지 이해하기 더 어려워진다.

* 테스트가 대상 코드가 하는 일을 서술하게 해서 대상 코드의 흐름을 파악할 수 있을 정보로 리팩터링 하는 것

### 단정과 예상구문

* 의도를 담아서!

### 리터럴과 변수 

* 테스트 코드는 제품 코드에 비해 구체적인데, 이것은 테스트 코드에 리터럴 값이 더 많다는 의미 
* 설명이 없는 리터럴 값은 이해하기 어렵다.
  * 리터럴 값을 변수나 상수에 할당하고, 그것들의 기능을 기술하는 이름을 부여해야 한다.
* 변수에 이름을 부여해 이러한 값이다 객체가 테스트에서 수행하는 역할과 그것들의 대상 객체와의 관계를 보여준다.

## 22장 복잡한 테스트 데이터 만들기 

* 테스트 코드에서 객체를 생성하는 코드 
  * 테스트 대상이 되는 행위에 기여하지 않는 정보로 테스트를 채워 넣어 테스트를 읽기 어렵게 만듬.
  * 생성자 인자나 객체 구조를 변경했을 때 여러 테스트가 깨질 것 = 테스트가 불안정해짐

* 해결 방법
  1. 객체 모체
  2. 테스트 데이터 빌더

### 객체 모체 

* 위의 문제를 방지
* 테스트에서 사용할 객체를 생성하는 여러가지 팩터리 메서드가 담긴 클래스
* 새 객체 구조를 만드는 코드를 묶고 거기에 이름을 부여함으로써 테스트의 가독성을 높인다.
* 테스트 사이에서 재사용할 수 있어 유지 보수에 도움이 된다.
* 하지만 테스트 데이터각 변형되면 잘 대처하지 못함 -> 사소한 차이가 있을 때마다 새로운 팩터리 메서드 필요

### 테스트 데이터 빌더

* 빌더 패턴을 사용하여 테스트에서 필요한 인스턴스 생성

* 중복을 줄이고 테스트 코드를 좀 더 표현력 있게 만듬.

* 팩터리 메서드와 테스트 골격을 조합한 형태로, 단순히 기능을 읶끌러 나가는 단계의 나열이 아니라 좀 더 읽기 쉽고 기능의 의도를 서술하는 선언적인 테스트를 작성하는 데 도움이 된다.

* 테스트 빌더 사용의 이점 

  * 테스트의 표현력을 유지하고 변화에 탄력적으로 대응

  * 객체 생성시 문법적으로 지저분한 부분을 가려줌.
  * 기존적인 경우를 단순하게 하고 특별한 경우라도 복잡하게 만들지 않음.
  * 테스트 객체의 구조적인 변화로부터 테스트를 다시 한 번 보호
  * 읽기 쉽고 오류를 찾기 쉬운 테스트 코드를 작성할 수 있다. -> 각 빌더 메서드가 매개변수의 용도를 밝히기 때문

  * 다수의 비슷한 객체를 생성할 때 유용하게 사용됨
  * 조합해서 객체 생성할 수 있음.
  * 팩터리 메서드를 이용하여 도메인 모델 강조 
  * 중복 없애기

## 23장 테스트 진단 

* 테스트의 핵심 : 실패하는 테스트 
  * 테스트 실패가 우리가 알아차리지 못했던 코드상의 암시적인 관계를 드러내기 때문

### 런타임시 도움이 되는 테스트 만들기

### 작고, 문제에 집중하고, 이름을 잘 지은 테스트

* 진단을 개선하는 가장 쉬운 방법 
* 21장 참고

### 설명력 있는 단정 메세지 

* 단정 메세지의 사용 : 어떤 단정이 실패했는지 알 수 있음. 단정 실패의 원인을 기술할 수 있음.

### 매처를 활용한 세부 사항 강조

### 자기 서술적인 값

* 단정에 세부 사항을 더하는 방법 : 단정 내의 값에 세부 사항을 추가하는 것 
* 단정에 세부 사항을 추가 : 실패를 좀 더 이해하기 쉽게 만들 수 있다는 힌트

### 명확하게 가공된 값

* 제품에서 기대할 법한 값과는 확연히 다른 별난 값을 사용하는 것

### 추적자 객체

### 예상이 충족됐음을 명시적으로 단정

