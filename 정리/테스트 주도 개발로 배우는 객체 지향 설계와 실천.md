# 테스트 주도 개발로 배우는 객체 지향 설계와 실천

## 1장 테스트 주도 개발의 핵심은 무엇인가?

###   TDD를 왜 해야 할까?

- 시스템 규모를 믿을 수 있는 방식으로 키우고, 예상치 못한 변화에 대처하기 위해 필요하다.
- 주기적인 피드백과 점진적인 개발 방식은 프로젝트와 관련된 사람들이 무엇을 달성해야 하는지 이애하고 그 과정에서 잘못 이해하고 있는 바를 식별하게 한다. 
  - 피드백
    - 가정을 갖고 작성한 코드에 대한 검사할 수 있는 기회 
    - 피드백 주기 -> 고리형 시스템 : 중첩된 고리 형태 안에서 피드백은 어디서나 오류, 오해를 포착하고 고칠 수 있는 기회를 만든다.
- TDD에서는 데스트를 설계 활동으로 바꾼다.

### TDD를 통해 얻을 수 있는 것은 무엇인가?

* 시스템 구현 - 시스템이 동작하는가?	
  * 컨텍스트를 선명하게 인지하는 동안 오류를 탐지한다.
* 시스템 설계 - 시스템이 잘 구조화돼 있는가?
  * 다음 작업에 대한 조건을 명확하게 알 수 있다.
  * 느슨하게 결합된 구성 요소를 작성할 수 있게 된다.
  * 코드가 하는 일에 대한 실행 가능한 설명이 더해진다. 
  * 완전한 회귀 스위트가 늘어난다.
  * 언제 작업이 충분히 완료 됐는지 알게 되어 과도한 최적화를 하거나 불필요한 기능을 더하지 않게 된다. 
* 외부 품질 유지 : 시스템이 고객과 사용자의 요구를 얼마나 잘 충족하는가 
* 내부 품질 유지 : 시스템이 개발자와 관리자의 요구를 얼마나 잘 충족하는가 -> 시스템 동작 방식을 안전하고 예상 가능한 상태로 바꿀 수 있게함

### TDD 황금률

> 실패하는 테스트 없이는 새 기능을 작성하지 말라.

### 리팩터링이란 무엇인가?

> 기존 코드의 작동 방식을 바꾸지 않은 채로 기존 코드의 내부 구조를 변경하는 것이다.
>
> 리팩터링의 핵심은 코드가 구현하는 기능의 표현을 개선해 코드를 좀 더 유지 보수할 수 있게 만드는 것이다.

* 리팩터링의 범위는 이해하기 쉽고 안전할 정도로 규모가 작아야 한다.

### 통합 테스트, 인수테스트란 무엇인가?

* 통합 테스트 
  * 변경할 수 없는 코드를 대상으로 코드가 동작하는가?
  * 일부 코드가 변경할 수 없는 팀 바깥의 코드를 어떻게 이용할지 검사하는 테스트 
  * 서드 파티 코드를 대상으로 만든 추상화가 기대한 대로 동작하는지 확인하기 위한 테스트 
* 인수 테스트
  * 프로젝트를 이끌어 가는 테스트 
  * 만들고자 하는 기능을 시험하는 테스트 
  * 전체 시스템이 동작하는가?
  * 전 구간 테스트 
    * 시스템 내부 코드를 가능한 한 직접 호출하지 말고 외부에서 유입되는 시스템과 상호작용하는 테스트
    * 시스템과 해당 시스템을 구축하고 배포하는 프로세스를 모두 시험

---

스터디 내용 

- 시스템을 개발하면서 만날 수 있는 어려움. 
  - 예측한 것과 실제가 다른것 
  - 예상하지 못한 변경
- 변화에 대처하기 위해 위해서는 우리가 어떤 기술적인 토대가 필요한가?
  - 테스트와 깨끗한 코드 
  - 왜?
    - 테스트를 작성하는 것은 잘 구조화된 코드를 생성한다.
    - 잘 구조화 된 코드는 깨끗한 코드와 관련이 있다. 
    - 테스트를 작성하는 것은 설계 활동이다.

---

## 2장 객체를 활용한 테스트 주도 개발 
### 객체지향이란 무엇인가?

* 하나의 책임을 수행하기 위해 각자 역할을 가지고 자율적으로 동작하는 객체들이 서로 협력하는 방식으로 프로그래밍 하는 것.
* 객체 지향 시스템 
  * 협업하는 객체의 망으로 구성
  * 시스템은 객체를 생성해 서로 메시지를 주고받을 수 있게 조립하는 과정을 거쳐 만들어진다.
* 객체 
  * 자신이 이해할 수 있는 메시지를 처리 
  * 내부 상태를 캡슐화 
  * 자율적으로 메시지를 처리 

### 값과 객체는 무엇이고, 어떤 차이점이 있는가?

* 값 
  * 변하지 않는 양이나 크기를 나타낸다.
  * 불변적
* 객체 
  * 시간이 지남에 따라 상태가 변한다. -> 시간의 추이에 따른 객체의 행위를 나타낸다.
  * 식별자가 있다.
  * 계산 절차를 담고 있다.
  * 가변적

### 메시지란 무엇인가?

* 다른 객체와 의사소통할 수 있는 수단
* 객체간의 의존성을 명시적으로 나타내는 것 
* 객체간의 의사소통(메시지)에 초첨을 맞추어 설계를 이끌어 나가야 한다. 
  * 왜 메시지 중심으로 설계를 이끌어 나가야 하는가?
    * 메시지 = 객체가 다른 객체에 접근할 수 있는 유일한 방법이다.
    * 메시지 = 메시지를 받은 객체가 수행해야 하는 책임을 의미한다.
    * 책임 = 객체가 무엇을 해야하는가? 를 설명한다.
    * 메시지에 초점을 맞춘다. = 객체가 무엇을 하는가에 초점을 맞춘다. 
    * 어떻게 하는가에 대해서는 객체가 자율적으로 선택하게 한다.
    * 시스템의 행위를 변경하기 쉽게 하여 시스템이 유연하도록 만든다.

### 디미터 법칙

* 디미터의 법칙 
  * 객체는 자기 자신을 책임지는 자율적인 존재여야 한다.
  * 객체는 내부적으로 보유하고 있거나 메시지를 통해 확보한 정보만 가지고 의사 결정을 내려야 한다.
  * 객체는 다른 객체를 탐색해 뭔가를 일어나게 해서는 안된다.

### mock 객체란 무엇인가?

* 테스트 대상이 되는 객체의 이웃을 대체하는 가짜 객체 
* 목 객체를 사용하면 객체 간의 관계를 파악하는 데에 도움이 된다.

### 테스트에서 목 객체를 어떻게 사용하는가?

1. 테스트 대상 객체의 이웃 객체를 목 인스턴스로 생성
2. 해당 목 인스턴스를 어떻게 호출하고 상태를 검사하는가에 관한 예상 구문 결정
3. 테스트시 스텁 형태로 동작할 필요가 있는 행위를 구현 

* 목 객체의 사용으로 단위 테스트는 대상 객체와 해당 객체를 둘러싼 환경 간의 관계를 명확하게 드러나게 만든다.

---

스터디 

* 메소드 체이닝과 열차 충돌의 차이 
  * 메소드 체이닝은 내부 구현이 들어나지 않지만 열차 충돌은 내부 구현 (세부 사항)을 드러낸다.

---

## 3장 도구 소개 

책 참고.

## 4장 테스트 주도 주기 시작

### 최초 기능의 역설

* 도구를 마련하고 동시에 마련한 도구로 테스트를 하면서 기능까지 구현하기 어려움 -> 안정적이지 못한 개발 환경
* 해결 : 2가지 문제로 쪼개기
  1. 동작하는 골격을 대상으로 빌드, 배포, 테스트하는 방법 파악
  2. 기반 구조(동작하는 골격)을 이용해 유의미한 첫 기능에 대한 인수 테스트 작성 

### 동작하는 골격이란 무엇인가?

* 전 구간을 대상으로 자동 빌드, 배포, 테스트를 할 수 있는 실제 기능을 가장 얇게 구현한 조각
* 빌드, 배포, 테스트를 나중으로 미루는 것은 위험하다.
* 프로젝트가 올바른 방향으로 나아가고 있는지 최대한 미리 파악해야 한다.
* 동작하는 골격 개발 = 애플리케이션의 개괄적인 구조를 결정하기 시작 
  * 초기 구조 설계하려면 시스템의 목적을 이해해야 한다.
  * 팀에서 자신들의 해법을 전체적으로 조망하는 데 이바지하게 끔 첫 테스트를 작성하는 과정을 활용해 프로젝트의 맥락을 짚어내는 것 

### 동작하는 골격을 먼저 만들어야 하는 이유는 무엇인가?
* 동작하는 골격은 프로젝트 초기에 각종 쟁점을 드러낸다.
* 불확실한 것을 먼저 발견하는 것이 중요하기 때문이다.
* 점진적 개발 = 프로젝트 초에는 불안정한 상태로 시작하지만 일부 기능을 구현하고 프로젝트 자동화가 구축되고 나면 반복적인 과정으로 안정화된다.
* 동작하는 골격 만들기 = 알아서 굴러가게 만들기 

----

스터디 

* 칠판에 간략하게 그리는 것 
  * 배포는 뭐로 할끼? aws로 할까? 
  * 자동화는?? 트래비스로 할까 github action을 쓸까??
* 동작하는 골격 = CI /CD까지 
* 가장 얇게 구현한 기능 = 리액트 기본 구조까지만 적는거??
* 지도앱을 만든다 -> 어떤 지도를 사용하는 지에 대해 기본만 구현하는 것 까지 동작하는 골격에 포함
* 지도에 대한 의존성을 분리하는 것은 프로젝트를 진행하면서 리팩터링 해 프로젝트를 진행시킬 것 

----

## 5장 테스트 주도 개발 주기의 유지 
1. 각 기능을 인수 테스트로 시작하라.

   * 인수 테스트를 작성하는 것으로 신기능을 작업 하는 데 착수 
   * 그 기능이 완성 되기 까지 진행 상황을 반영한다. -> 프로젝트를 나아가게 함.

2. 회귀를 포착하는 테스트와 진행 상황을 추적하는 테스트를 분리하라.

   * 인수 테스트 통과 주기 : 중첩된 프로젝트 피드백 고리를 구동하는 엔진

   * 회귀를 포착하는 테스트 : 기존 코드의 망가짐을 확인하는 것 (?)
   * 진행 상황을 측정하는 테스트 : 새로운 인수테스트 (?)

3. 테스트를 가장 간단한 성공 케이스로 시작하라.

   * 시스템에 가치를 더하고 아이디어의 유효성에 관해 충분한 피드백을 주는 테스트 케이스를 작성하라.

4. 읽고 싶어할 테스트를 작성하라.

   * 가능한한 명확하게 표현해야 한다.
   * 잘 읽히는 테스트 -> 테스트를 그 다음으로 지원하는 기반 구조를 만든다.

5. 테스트가 실패하는 것을 지켜보라.

   * 오류 메시지를 검사해야 하는 이유 
     * 현재 작업중인 코드에 대한 가정을 확인하기 위해 
     * 테스트와 실패 메시지는 코드가 의도( 무엇을 해야 하는지 )를 강조하는 표현이기 떄문이다. -> 신뢰성있고 유지하기 쉬운 시스템을 개발하는 데 필수 

6. 입력에서 출력 순서로 개발하라.

   * 기능 개발을 시작할 때 가장 먼저 시스템이 새로운 행위를 일으키게 하는 이벤트를 고려함.
   * 외부 이벤트를 받는 객체 -> 중간 계층 -> 중심 도메인 

7. 메서드가 아닌 행위를 단위 테스트하라.

   * 행위 = 테스트의 목적을 알려주기 때문
   * 테스트 -> 무엇을 테스트 하는가, 왜 테스트 하는가가 중요
   * 테스트 이름 짓기 
     * 객체의 책임이 무엇인가 
     * 객체의 여러 메서드가 어떻게 함께 동작하는지 

8. 테스트에 귀를 귀울이라.

   * 테스트하기 어려운 기능 발견 -> 스스로에게 묻기
     * 기능을 어떻게 테스트할 것인가 
     * 왜 테스트하기 어려운가 
   * 테스트하기 어렵다. -> 설계 개선이 필요하다.

> TDD의 테스트 부분에서 얻을 수 있는 최고의 혜택은 코드를 망가뜨리지 않고도 변경할 수 있다는 자신감이다. 진행을 막는 것은 바로 두려움이다.

## 6장 객체 지향 스타일

### 포드 어댑터 아키텍처란 무엇인가?

* 비즈니스 도메인의 코드가 데이터베이스나 사용자 인터페이스 같은 기술 기반 구조의 의존성과 격리된 아키텍처
  * 포트 : 인터페이스를 작성해 애플리케이션 모델과 외부 세계의 관계를 애플리케이션 모델의 용어로 기술 
  * 어댑터 (손상 방지 계층) : 애플리케이션의 핵심부와 각 기술 도메인 사이에서 브리지 역할을 하는 코드 
    * 애플리케이션 모델에서 정의한 인터페이스를 구현하고 애플리케이션 수준의 객체와 기술 수준의 객체를 매핑한다.
* 관심사의 분리 : 시스템의 동작 방식을 변경할 경우, 되도록 적은 양의 코드를 변경 하고자 함. -> 변경 이유가 같은 코드끼리 모은다.
* 더 높은 수준의 추상화 : 복잡성을 다루는 방법. 유용한 기능 컴포넌트를 조합하는 식으로 프로그램 작성.

### 캡슐화와 정보 은닉

[객체지향의 올바른 이해 : 정보 은닉](https://effectiveprogramming.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%A0%95%EB%B3%B4-%EC%9D%80%EB%8B%89information-hiding%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%9D%B4%ED%95%B4)

[정보은닉](http://egloos.zum.com/aeternum/v/1232020)

* 캡슐화 : 객체의 행위가 해당 객체의 API를 통해서만 좌우될 수 있음을 보장
  * 데이터를 공용 메서드를 통해서만 접근하도록 어용하는 방법
* 정보 은닉 : 객체가 해당 객체의 기능을 구현하는 방법을 추상화된 API 너머로 감추는 것
  * 모듈( 책임의 할당 )을 분할하기 위한 기본 원리 
  * 복잡하고 변경 가능한 설계 결정을 안정적인 인터페이스 뒤로 숨기는 기본 설계 원리
  * 코드가 구체적인 것에 의존하는 것을 막음으로써 변경에 대한 유연성을 제공하는 것 

* 시스템을 구성할 때는 각 객체의 안팎으로 무엇을 둘지 결정해 해당 객체가 명확한 API와 함께 응집력 있는 추상화를 제공하게 해야 한다.
  * API를 통해 해당 객체의 내부에 접근하는 것을 캡슐화하고, 세부 사항을 시스템의 나머지 부분으로부터 감추는 것 

### 단일 책임 원칙

* 특정 객체에게 어울리는 기능을 선택하기 위한 기준(?)
* 모든 객체는 반드시 단 한 가지 명확히 규정된 책임을 지녀야 한다.
  * 객체의 역할을 한 절로 설명.
* 여러 객체를 조합해 새로운 추상화를 만드는 데도 적용 
  * 여러 객체에 걸쳐 구현된 행위를 단일 구성물로 뭉뚱그릴 경우 해당 구성물의 역할을 명확하게 설명할 수 있어야 한다.
  * 전체는 부분의 합보다 단순해야 한다.
  * 컨텍스트 독립성

### 전체는 부분의 합보다 단순해야 한다. 의 의미는 무엇인가?

* 복합 객체의 API는 반드시 구성 요소의 존재와 구성 요소 간의 상호 작용을 감추고 더 단순한 추상화를 이웃에게 드러내야 한다.
* 코드 규모가 커짐에 따라 추상화 수준을 높일 수 있는 규칙이 된다.

### 컨텍스트 독립성이란 무엇인가?

* 컨텍스트 독립적 : 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다.
  * 컨텍스트 독립성 : 한 객체가 정보를 너무 많이 감췄거나 잘못된 정보를 감췄는지 판단하는 데 유용하다.
* 컨테스트에 대해 독립적이다. 컨텍스트에 대한 정보가 적다 -> 객체가 다양한 컨텍스트에서 재사용 될 수 있다
* ❓❓❓❓예시 

## 7장 객체 지향 설계의 달성

### 테스트 작성은 설계에 어떻게 도움이 되는가?

### 인터페이스와 프로토콜의 차이는 무엇인가?

### 값 타입을 사용하는데 이점은 무엇인가?

### 값 타입 객체는 어떻게 만들어지는가?

### 인터페이스는 언제 리팩토링해야 하는가?

### 구현 계층, 선언 계층은 무엇인가? 왜 분리하는가?







----

무엇 때문에 프로젝트가 난항을 겪고 있는가?