# 클린 아키텍처 

> 제대로 된 소프트웨어를 만들면 아주 적은 인력만으로도 새로운 기능을 추가하거나 유지보수할 수 있다. 변경은 단순해지고 빠르게 반영할 수 있다. 결함은 적어지고 잦아든다. 최소한의 노력으로 기능과 유연성을 최대화할 수 있다.

## 1장 설계와 아키텍처란?

* 설계와 아키텍처의 차이 

  * 아키텍처 : 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용됨

  * 설계 : 저수준의 구조 또는 결정사항 등을 의미

  * 실제로는 아무런 차이가 없다. 

  * 저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소 

    -> 이 둘은 단절 없이 이어진 직물과 같으며, 이를 통해 대상 시스템의 구조를 정의한다.

* 아키텍처의 목표 

  * 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다. 
  * 비용이 적게 들어가는 소프트웨어 = 좋은 설계로 만들어짐.
  * 아키텍처의 품질을 심각하게 고민할 것

  >엉망으로 만들면 깔끔하게 유지할 때 보다 항상 더 느리다.

## 2장 두 가지 가치에 대한 이야기 

* 소프트웨어 시스템 -> 이해관계자에게 두 가지 가치를 제공함. 

  * 개발자는 두 가치를 모두 반드시 높게 유지해야 하는 책임이 있다.
  * 행위 : 시스템의 기능, 요구사항을 구체화 하는 것 
  * 구조 : 변경 사항에 대해 쉽게 변경될 수 있는 구조 
    * 변경사항을 적용하는 데 드는 어려움은 변경되는 범위에 비례해야 하며, 변경사항의 형태와는 관련이 없어야 한다.
    * 아키텍처가 특정 형태를 다른 형태 보다 선호하면 할수록, 새로운 기능을 구조에 맞추는 게 더 힘들어진다. 
    * 아키텍처는 형태에 독립적이어야 하고 그럴수록 더 실용적이다.

* 더 높은 가치 

  > 객체지향의 사실과 오해 참고 
  >
  > 불안정한 기능을 안정적인 구조안에 담음으로써 변경에 대한 파급 효과를 줄인다.

## 3장 패러다임 개요

* 프로그래밍 패러다임 
  * 프로그래밍을 하는 방법 
  * 언어에 독립적 
  * 어떤 프로그래밍 구조를 사용할지, 언제 이 구조를 사용해야 하는지를 결정한다.
* 구조적 프로그래밍 : 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
* 객체 지향 프로그래밍 : 제어흐름의 간접적인 전환에 대해 규칙을 부과한다. 
* 함수형 프로그래밍 : 할당문에 대해 규칙을 부과한다.
* 패러다임 패턴 
  * 각 패러다임은 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과한다. 
  * 무성을 해야 할지를 말하기 보다는 무엇을 해서는 안 되는지를 말해준다.

## 4장 구조적 프로그래밍

* 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 됨 

  -> 모듈을 기능적으로 분해할 수 있음.

  -> 거대한 문제를 고수준의 기능들로 분해할 수 있음

* 구조적 프로그래밍의 사용

   -> 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는( 테스트할 수 있는?) 아주 작은 기능들로 세분화할 수 있다.

* 테스트 

  > 테스트는 버그가 있음을 보여줄 뿐 버그가 없음을 보여줄 수는 없다.
  >
  >
  > 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 분해할 것을 강요한다. 그러고 나서 테스트를 통해 증명 가능한 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다.

  * 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만 프로그램이 맞다고 증명할 수는 없다. -> 부정확함에 대한 증명 

## 5장 객체 지향 프로그래밍

* 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대해 절대적인 제어 권한을 획득할 수 있는 능력
* 객체 지향의 사용
  * 플러그인 아키텍처 구성가능
  * 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있음
  * 모듈별로 독립적으로 개발하고 배포할 수 있다.
* 캡슐화 : 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있는 장치 -> 정보 은닉 가능
* 다형성 
  * 이전에는 함수 포인터를 사용하여 다형성을 구현 -> 위험
  * OO언어는 다형성을 좀 더 안전하고 편리하게 사용할 수 있게 함.
    * 다형성을 통해 안전하게 제어흐름을 간접적으로 전환할 수 있게 함.
  * 다형성이 등장하기 전 소프트웨어 : 소스 코드의 의존성 방향 == 제어 흐름
    * 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.
  * 다형성의 사용 : 소스 코드의 의존성 방향 != 제어흐름
    * 소스 코드 사이에 인터페이스를 추가함으로써 의존성의 방향을 역전 시킬 수 있다.

## 6장 함수형 프로그래밍 

