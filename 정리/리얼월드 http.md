

# 리얼월드 HTTP

## 1장. HTTP/1.0의 신택스 : 기본이 되는 네가지 요소 

* http란 무엇인가? 

  * 웹 브라우저와 웹 서버가 통신하는 절차와 형식을 규정한 것
  * 다양한 서비스의 인터페이스로도 사용된다.

* http/0.9의 한계 

  * 하나의 문서를 전송하는 기능밖에 없었다. -> 그럼 현재는 여러가지 문서를 전송할 수 있나?
  * 통신되는 모든 내용은 html 문서로 가정했으므로, 다운로드할 콘텍츠의 형식을 서버가 전달할 수단이 없었다.
  * 클라이언트 쪽에서 검색 이외의 요청을 보낼 수 없었다. 
  * 새로운 문장을 전송하거나 갱신 또는 삭제할 수 없었다.

* http/1.0에서 추가된 내용

  * 요청 시 
    * 메서드 
    * http 메서드 
    * 헤더 
  * 응답 시 
    * http버전과 스테이터스 코드 
    * 헤더 

* 헤더 [헤더 - MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers)

  * 이름 : 값 형태 

  * 본문 이외의 모든 정보를 포함하는 곳 

  * 서버와 클라이언트 사이에 필요한 추가 정보, 지시나 명령, 당부 등을 쓰는 장소 

  * 클라이언트 -> 서버 헤드

    * User-Agent : 클라이언트가 자신의 이름을 넣는 곳 
    * Referer : 서버에서 참고하는 추가 정보. 클라이언특각 요청을 보낼 때 보곡있던 페이지의 URL을 보낸다.
    * Authorization : 특별한 클라이언트에만 통신을 허가할 때 인증 정보를 서버에게 전달. 

  * 서버 -> 클라이언트 

    * Content-Type : 파일의 종류를 지정. MIME 타입이라는 식별자를 기술한다.
    * Content-Length : 바디 크기. 압축이 이루어지는 경우 압축 이후의 크기가 들어간다.
    * Content-Encoding : 압축이 이루어진 경우 압축 형식을 설명
    * Date : 문서 날짜

  * MIME 타입 [MIME - MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types)

    * 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘

    * 브라우저들은 리소스를 내려받았을 때 해야할 기본 동작이 무엇인지를 결정하기 위해 대게 MIME 타입을 사용.

    * 구조 :

      * type/ sub type -> text / html 

      * type = 카테고리. 개별 혹은 멀티파트 타입이 될 수 있다. 

        * 멀티파트 타입 : 

          일반저으로 다른 MIME 타입들을 지닌 개별적인 파트들로 나누어지는 문서의 카테고리를 가리킨다. 

          * 합성된 문서를 나타내는 방법 

      * subtype = 각각의 타입에 한정되는 값이 들어간다. 

    * [정확한 MIME타입 설정의 중요성](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types#%EC%A0%95%ED%99%95%ED%95%9C_mime_%ED%83%80%EC%9E%85_%EC%84%A4%EC%A0%95%EC%9D%98_%EC%A4%91%EC%9A%94%EC%84%B1)

    * MIME 스니핑 

      * 브라우저에서 리소스를 훑어보고 정확한 MIME 타입을 추측해내는 것 
      * MIME 타입이 없을 때 혹은 클라이언트가 타입이 잘못 설정됐닥고 판다한 경우에, 브라우저들은 MIME 스니핑을 시도할 수 있다. 
      * 보안의 구멍이 될 수 있다.

* 메서드 ([메서드- MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods))

  * 주어진 리소스에 수행하길 원하는 행동을 나타냄. 리소스에 대한 조작을 서버에 지시.
  * 응답 메서드는 안전하거나, 캐시 가능하거나, 멱등성을 가질 수 있다. 

* 스테이터스 코드 ([스테이터스 코드 - MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Status))

  * 특정 http 요청에 대한 응답 코드 
  * 1xx : 조건부 응답 - 처리가 계속 됨을 나타낸다.
  * 2xx : 성공 - 성공했을 때의 응답 
  * 3xx : 리다이렉션 
    *  서버에서 클라이언트로의 명령.
    *  오류가 아니라 정상 처리의 범주. 
    *  클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다. 
    *  클라이언트는 응답의 Location헤더를 보고 해당 주소로 다시 요청한다. 
    *  리다이렉트하는 곳이 다른 서버라면 리다이렉트할 때 마다 TCP세션 접속, HTTP 송수신으로 두 번 왕복 통신이 발생한다. -> 리다이텍트 수가 늘어나면, 그만큼 표시에 걸리는 시간이 늘어난다.
  * 4xx : 요청 오류 (클라이언트 에러) - 클라이언트가 보낸 요청이 오류가 있다.
  * 5xx : 서버 오류 (서버 에러) - 서버 내부에서 오류가 발생했다.

## 2장. HTTP/1.0의 시맨틱스 : 브라우저의 기본 기능의 이면

* 브라우저의 기본 요소 응용, 기본 기능 실현

* 폼 전송 

  * Content-type : 

    * 리소스의 미디어 타입을 나타내기 위해 사용되는 헤더 
    * POST 메서드를 사용하여 서버로 데이터를 보낼 때, 요청 본문의 유형을 나타내는 헤더 

    ---

    참고 : html form 태그의 enctype속성 [w3c](https://www.w3schools.com/tags/att_form_enctype.asp)

    서버로 데이터를 보낼 때 form-data를 어떻게 인코딩할 것인지에 대한 설정 

    ```html
    <form method="post" enctype="multipart/form-data">
      ...
    </form>
    ```

    ---

    * x-www-form-urlencoded [MDN참고](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/POST)

      * 모든 문자들은 서버로 보내지기 전에 인코딩됨을 명시

      * html에서 form으로 데이터를 전송할 때 enctype을 설정하지 않으면 기본으로 적용되는 값

      * &으로 분리되고 '='으로 값과 키를 연결하는 key-value tuple로 인코딩하는 방법 

      * 알파벳, 수치, 별표, 하이픈, 마침표, 언더스코어를 제외한 문자들은 percent endcoded로 인코딩된다. -> 바이너리 데이터를 사용하기에는 적합하지 않다.

        ```html
        POST / HTTP/1.1
        Host: foo.com
        Content-Type: application/x-www-form-urlencoded
        Content-Length: 13
        
        say=Hi&to=Mom
        ```

    * multipat/form-data [MDN 참고](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types#multipartform-data)

      * 모든 문자를 인코딩하지 않음을 명시
      * 서버로 파일이나 이미지를 전송할 때 사용하는 인코딩 방법
      *  multipart를 이용하는 경우 한 번의 요청으로 복수의 파일을 전송할 수 있다.
        * 받는 쪽에서는 boundary를 통해 파트를 구분한다.
        * boundary는 각 브라우저가 독자저인 포맷으로 랜덤하게 만든다. 
      * 항목마다 추가 메타 정보를 태그로 가질 수 있다.

      ```html
      <form action="http://localhost:8000/" method="post" enctype="multipart/form-data">
        <input type="text" name="myTextField">
        <input type="checkbox" name="myCheckBox">Check</input>
        <input type="file" name="myFile">
        <button>Send the file</button>
      </form>
      
      
      POST / HTTP/1.1
      Host: localhost:8000
      User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
      Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
      Accept-Language: en-US,en;q=0.5
      Accept-Encoding: gzip, deflate
      Connection: keep-alive
      Upgrade-Insecure-Requests: 1
      Content-Type: multipart/form-data; boundary=---------------------------8721656041911415653955004498
      Content-Length: 465
      
      -----------------------------8721656041911415653955004498
      Content-Disposition: form-data; name="myTextField"
      
      Test
      -----------------------------8721656041911415653955004498
      Content-Disposition: form-data; name="myCheckBox"
      
      on
      -----------------------------8721656041911415653955004498
      Content-Disposition: form-data; name="myFile"; filename="test.txt"
      Content-Type: text/plain
      
      Simple file.
      -----------------------------8721656041911415653955004498--
      ```

* 컨텐츠 협상 [Content negotiation - MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation)
  * 동일한 URI에서 리소스의 서로 다른 버전을 서브하기 위해 사용되는 메커니즘 
  * 클라이언트에 적합한 리소스를 제공하기 위한 구조 (언어, 이미지 포맷, 인코딩 등등)
  * 협상 대상
    * MIME 타입 (Accept / Content-type )
    * 언어 (Accept-Language / Content-Language, html 태그)
    * 문자셋 (Accept-Charset / Content-Type)
      * 바디 압축(Accept-Encoding / Content-Encoding)
  * 협상 방식 (참고 : 그림으로 배우는 http & network basic)
    1. 클라이언트가 보내는 HTTP 헤더를 이용하는 방법 (서버 구동형 또는 서버 주도 협상)	
       * 서버 측에서 콘텐츠 협상을 하는 방법
       * 서버 측에서 요청 헤더 필드의 정보를 참고해서 자동적으로 처리 
       * 한계
         * 서버는 클라이언트의 모든 정보를 알고 있지 않음. -> 선택한 리소스가 클라이언트에 적합하지 않을 수도 있음
         * 클라이언트의 정보가 많음 -> 메시지의 크기가 커짐.
         * 캐식가 덜 효율적일 수 있음. 서버 구현이 복잡해짐
    2. 서버에 의해 전달되는 HTTP응답 코드를 이용하는 방법 (에이전트 구동형 또는 에이전트 주도 협상)
       * 클라이언트 측에서 콘텐츠 협상을 하는 방법
       * 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택 
       * 한계 
         * 실제 리소스를 가져오는데 한 개 이상의 요청을 필요로 함 -> 리소스 효용이 떨어짐
         * HTTP표준에서 이 과정을 자동화 하는 방법을 막음 -> 거의 리다이렉션과 함께 사용됨
    3. 트랜스페어런트 네고시에이션 
       * 서버 구동형과 에이전트 구동형을 혼합한 것으로 서버와 클라이언특가 각각 콘텐츠 협상하는 방법
  
* 쿠키 [쿠키 - mdn](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)
  * 웹사이트의 정보를 저장하는 작은 파일. 서버가 웹브라우저에 전송하는 작은 데이터 조각.(서버가 클라이언트에 쿠키 저장을 지시)
  * 주로 요청이 동일한 브아우저에서 들어왔는지 아닌지 판단할 때 주로 사용한다. 
  * 상태 정보를 유지할 수 있음. (http는 기본적으로 스테이트리스 프로토콜)
  * 쿠키의 목적
    * 세션 관리 : 서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리 
    * 개인화 : 사용자 선호, 테마 등의 세팅
    * 트래킹 : 사용자의 행동을 기록하고 분석하는 용도
  * 쿠키의 잘못된 사용법
    * 영속성 문제 
      * 쿠키가 어떤 상황에서도 확실하게 저장되는 것은 아님.
      * 비밀 모드 혹은 브라우저의 보안 설정에 따라 세션이 끝나면 초기화되거나 쿠키를 보관하라는 서버의 지시를 무시할 수 있음.
    * 용량 문제
      * 쿠키의 최대 크기는 4킬로 바이트.
    * 보안 문제 
      * HTTP 통신에서는 쿠키가 평문으로 전송됨.
      * 원리상 사용자가 쿠키를 수정하는 것도 가능함.
  * 쿠키의 제약 
    * 쿠키를 보낼 곳을 제어, 쿠키의 수명을 설정하는 등의 쿠키를 제한하는 속성이 있음.
    * Expires, Max-Age : 쿠키의 수명을 설정
    * Domain : 클라이언트에서 쿠키를 전송할 서버 설정. 쿠키의 스코프를 결정
    * Path : 클라이언트에서 쿠키를 전송할 대상 서버의 경로. Domain과 마찬가지로 쿠키의 스코프를 결정.
    * Secure : https 프로토콜을 사용한 보안 접속일 때만 클라이언트에서 서버로 쿠키를 전송한다.
    * HttpOnly : 크로스 사이트 스크립팅(XSS)공격을 방지하기 위해 사용. 자바스크립트에서 Document.cookie API에 접근할 수 없음.
  
* 인증과 세션 

  * 기본 인증 

    * basic 인증과 digest인증의 한계 
      * 특정 폴더 아래를 보여주지 않는 방식 . 탑페이지에 사용자 고유 정보를 제공할 수 없다.
      * 요청시 마다 사용자 정보를 보내고 계산하여 인증. 계산량 많음
      * 명시적인 로그오프를 할 수 없다.
      * 로그인한 단말을 식별할 수 없다.
    * 한계 극복 => 폼을 이용한 로그인과 쿠키를 이용한 세션관리 

    * basic인증 : 가장 간단한 인증 방법

      * 유저명과 패스워드를 BASE64로 인코딩한 것
      * base64 = 가역변환. 서버로부터 복원해 원래 유저명과 패스워드를 추출할 수 있다.
      * 감청시 손쉽게 로그인 정보가 유출됨.

    * digest인증 

      * 참고 

        * [다이제스트 인증](http://iloveulhj.github.io/posts/http/http-digest-auth.html)

      * 해시 함수를 이용

      * 서버가 WWW-Authenticate(헤더) 인증 요구 메세지를 를 클라인언트에 전송

        ```html
        WWW-Authenticate : Digest realm="shopping cart", nonce="12345", algorithm="MD5", qop="auth" 
        ```

        * realm : 보안영역 (예시 : 쇼핑카트). 사용자의 이름과 비밀번호가 어디 사용될 것인지 알려주기 위해 사용자에게 보여질 문자열
        * nonce : 서버가 매번 생성하는 랜덤 데이터. 재전송 방지를 위해 사용됨. 다이제스트를 탈취하여 서버로 전송하는 해킹을 막기위한 방법
        * algorithm : 다이제스트와 체크섬을 생성할 때 사용하는 알고리즘.
        * qop : 보호 수준.  클라이어트와 서버가 어떤 보호 기법을 어는 정도 수준으로 사용할 수 있을 지 협상할 수 있게 허용

      * 클라이언트에서는 받은 헤더값을 사용하여 response를 구하여 Authorization헤더에 넣고 전송 

        * response 구하기 

          ```html 
          A1 = 유저명 ":" realm ":" 패스워드 
          A2 = HTTP메서드 ":" 콘텐츠 URI
          response : 
          MD5(MD5(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" MD5(A2) )
          ```

          * nc : 클라이언트 이 요청의 nonce값과 함께 보낸 요청들의 횟수 합계. qop가 없을 때는 생략 -> nc값이 다시 사용된 것을 알 수 있음. 서버가 리플레이 공격을 탐지할 수 있음.
          * response : 다이제스트 값. 사용자가 비밀번호를 알고 있음을 증명 
          * cnonce : qop가 있을 때만 포함. 메시지 무결성 제공 

        * 헤더에 넣고 전송

        ```html
        Authorization : Digest user="user name", realm="shopping cart", nonce="5678", algorithm="MD5", qop="auth", nc="00000001", cnonce="01234567", response="adfdsf" 
        ```

        * 서버측에서 이 헤더에 있는 정보와 서버에 있는 저장된 유저명, 패스워드로 같은 계산을 실시 
        * 재발송된 요청과 동일한 response가 계산되면 사용자가 정확하게 유저명과 패스워드를 입력했음을 보장할 수 있다.

  * basic 인증과 digest인증의 한계 극복 : 폼을 이용한 로그인과 쿠키를 이용한 세션관리 

    * digest인증과 달리 유저 아이디와 패스워드를 직접 송신 => SSL/TLS필수 

    1. 서버측에서 유저 아이디와 패스워드로 인증하고 문제가 없을 경우 세션 토큰 발행 
    2. 발행된 토큰은 
       * 서버 : 키, 밸류 형태로 데이터베이스에 저장
       * 클라이언트 : 서버로부터 쿠키 헤더를 통해 토큰을 받음.
    3. 두 번째 이상 접속시 쿠키를 재전송하여 로그인된 클라이언트임을 서버가 알 수 있음.

* 프록시 

  * http등의 통신을 중계 
  * 악용되는 경우 방지를 위해 Proxy-Authenticate헤더를 사용하기도 함.
  * gateway(게이트 웨이)와 차이 
    * 게이트 웨이 : 통신 내용을 그대로 전송한다. 내용의 수정도 불허한다. 클라이언트에서는 중간에 존재하는 것을 알아채서는 안된다.
    * 프록시 : 통신 내용을 이해한다. 필요에 따라서 콘텐츠를 수정하거나 서버 대신 응답한다. (캐시 같은 경우!)

* 캐시 

  * 콘텐츠가 변경되지 않았을 땐 로컬에 저장된 파일을 재사용함으로써 다운로드 횟수를 줄이고 성능을 높임.

  * GET, HEAD 이외의 메서드는 기본적으로 캐시되지 않음.

  * 캐시 설정하는 방법

    * 갱신일자에 따른 캐시 

      * Last-Modified : 서버가 클라에 보내는 헤더. 
      * If-Modified-Since : 웹 브라우저가 캐시된 URL을 다시 읽을때는 서버에서 반환된 일시를 그대로 이 헤더에 넣어 요청함. => 서버에서 헤더에 포함된 일시와 서버에 있는 콘텐츠의 일시를 비교하여 다시 보낼지 캐시한 것을 사용할 지 결정

    * Expires헤더 

      * 갱신 일시를 이용하는 캐시의 경우 캐시의 유효성을 확인하기 위해 통신이 발생함.
      * Expires헤더를 통해 통신을 없앨 수 있음.
      * expires 기간 내의 콘텐츠인 경우 => 신선. 캐시사용
      * 유효기간을 지난 콘텐츠인 경우 => 시선하지 않다고 판단

    * Pragma : no-cache

      * 요청한 콘텐츠가 이미 저장돼 있어도, 원래 서버에서 가져오라고 프록시 서버에 지시하는 것

    * Etag

      * 동적으로 바뀌는 요소가 많은 콘텐츠에 적합.
      * 순차적 갱신 일시가 아니라 파일의 해시 값으로 비교 
      * If-None-Match헤더 사용. 캐시에 있는 Etag값 사용 => 서버에 있는 파일과 캐시된 파일의 Etag값이 같으면 304 Not Modifed로 응답.

    * Cache-Control

    * Vary

      * 같은 URL이라도 클라이언트에 따라 반환 결과가 다름을 나타내는 헤더 

      * 예시 

        : 사용하는 브라우저가 모바일 브라우저일 때는 모바일 페이지로 표시, 또는 언어에 따라 바뀌는 경우  => 해당하는 헤더명을 vary에 나열함으로써 잘못된 콘텐츠의 캐시로 사용되지 않게함.

        ```html 
        Vary : User-Agent, Accept-Language
        ```

        

* 리퍼러 (Referer헤더)

  * 사용자가 어느 경로롤 웹사이트에 도달했는지 서버가 파악할 수 있도록 클라이언트가 서버로 보내는 헤더 

## 3장. Go언어를 이용한 HTTP/1.0 클라이언트 구현

* go 언어에서 제공하는 http관련 api 학습

## 4장. HTTP / 1.1 의 신택스 : 고속화와 안전성을 추구한 확장

* HTTP /1.1의 변경사항 -> 더 나은 통신을 위해 추가된 내용
  * 통신 고속화 
    * Keep-alive
      * HTTP의 아래층인 TCP/IP 통신을 효율화하는 구조.
      * Keep-alive를 사용할 경우 연속된 요청에는 이전에 사용했던 접속을 다시 사용.
        * TCP/IP는 접속까지의 대기 시간이 줄어듬.
        * 핸드셰이크 횟수를 줄일 수 있음. => 반복되는 핸드셰이크를 줄임으로써 응답 시간을 개선할 수 있음.
      * Keep-alive이전 : 요청후에 접속을 닫음. 재사용 불가 
      * 클라이언트나 서버 중 한 쪽이 `Connection : close` 헤더를 부여해 접속을 끊거나 타임아웃될 때까지 연결을 유지함.
    * 파이프라이닝
      * 고속화를 위한 기능
      * 최초의 요청이 완료되기 전에 다음 요청을 보내는 기술.
      * 다음 요청까지의 대기 시간을 없앰으로써 네트워크 가동률을 높이고 성능을 향상시킴.
      * Keep-alive 이용을 전제로 함.
      * 서버는 요청이 들어온 순서대로 응답.
      * HOL블로킹 문제가 있을 수 있음.
  * TLS에 의한 암호화 통신 지원
    * Transper Layer Security 전송 계층 보안
      * 통신 경로를 암호화함. 조작할 수 없는 안전한 통신로가 생김.
      * 클라이언트와 서버 간 통신 경로를 전혀 신뢰할 수 없는 상태에서도 안정하게 통신할 수 있도록 설계 
      * 공통키의 안전한 교환이 중요함.
    * TLS 암호화 
      * HTTP뿐만 아니라 다양한 형식의 데이터를 양방향으로 흘려보낼 수 있음.
      * 기존 프로토콜 통신 경로의 안전성을 추가해 새로운 프로토콜을 만들어 낼 수 있는 범용적인 구조.
      * 해시 함수 
        * 입력 데이터를 규칙에 따라 집약해감으로써 해시 값이라고 불리는 짧은 데이터를 만듬.
        * 해시 함수 특성 
          * 같은 알고리즘과 같은 입력 데이터라면, 결과로서 생성되는 값은 같다.
          * 해시 값은 알고리즘이 같으면 길이가 고정된다.
          * 해시 값에서 원래 데이터를 유추하기 어렵다.
          * 같은 해시 값을 생성하는 다른 두 개의 데이터를 찾기 어렵다.
        * 해시 값은 핑거 프린트 또는 체크섬으로 사용됨.
      * 대칭 키 암호(공통 키), 비대칭 키(공개 키) 암호, 디지털 서명 
        * 대칭 키 : 암호화, 복호화 시 같은 키를 사용하는 암호화 방식
        * 비대칭 키 : 암호화, 복호화 시 다른 키를 사용하는 암호화 방식. 암호화 시 사용되는 키는 공개 키, 복호화 시 사용되는 키는 비밀 키 
        * TLS에서는 통신마다 한 번만 사용되는 공통 키를 만들어내고, 공개 키 방식을 사용해 통신 상대에게 신중히 키를 전달한 이후는 공통 키로 고속으로 암호화하는 2단계 방식을 사용한다.
        * 디지털 서명 : 공개 키 방식을 응용한 예 
      * 키 교환 알고리즘 : 키 자체를 교환하는 게 아니라, 클라와 서버에서 각각 키 재료를 만들어 서로 교환하고 각자 계산해서 같은 키를 얻는 것.
    * TLS 통신 절차 
      1. 핸드셰이크로 통신을 확립
         * 서버의 신뢰성을 확인
           * 공개 키(비대칭 키 )를 보증하는 구조 (= 공개키 기반 구조, PKI)
           * 브라우저는 서버에서 그 서버의 ssl 서버 인증설를 사져오는 것부터 시작한다.
           * 인증서
             *  사이트 주체, 발행자(인증기관, CA) ,소유자 서버의 공개 키, 유효기간 등의 항목이 있음.
             * 신뢰성의 핵심 = 발행자 
             * 인증서에는 발행자의 디지털 서명이 있음.
         * 키교환과 통신 시작
           * 키 교환 
             * 공개 키 암호를 사용하는 방식 : 서버 인증서에 첨부된 공개 키로 통신용 공통 키를 암호화해 서버로 보냄
             * 키 교환 알고리즘을 사용하는 방식 : 
               * 키를 생성할 시드를 클라, 서버 양측에서 만듬 -> 만들어진 시드를 서로 교환해서 계산한 결과를 공통 키로 사용함.
               * 순방향 비밀성이 우수함.
      2. 레코드 프로토콜 (통신 단계)
      3. sessionTIcket 구조를 이용한 재접속 시의 고속 핸드셰이크
  * 새 메서드 추가 
    * PUT, DELETE
    * OPTION, CONNECT, TRACE
  * 프로토콜 업데이트 
  * 가상 호스트 지원
    * 서버가 하나의 웹 서버로 여러 웹 서비스를 운영하여도 Host헤더를 통해서 해당하는 서비스에 접근할 수 있음.
    * 서버에서 Host헤더의 정보를 바탕으로 같은 서버에서 콘텐츠를 구분해 요청한 서비스에 해당하는 콘텐츠를 보내줄 수 있음.
  * 콘텐츠의 청크 전송 인코딩 지원
    * 전체를 한꺼번에 전송하지 않고 작게 나눠 전송하는 방식
    * 청크를 사용할 경우 시간이 오래 걸리는 데이터 전송을 조금씩 앞당길 수 있음.

## 5장. HTTP/1.1의 시맨틱스 : 확장되는 HTTP의 용도

## 6장. GO언어를 사용한 HTTP1.1클라이언트 구현 

## 7장. HTTP/2의 신택스 : 프로토콜 재정의 

* HTTP/1.1과 달라진 점 

  * 스트림을 사용해 바이너리 데이터를 다중으로 송수신하는 구조로 변경했다. 
  * 스트림 내 우선 순위 설정과 서버 사이드에서 데이터 통신을 하는 서버 사이드 푸시를 구현했다.
  * 헤더가 압축되게 되었다.

* 하위 호환성 문제가 일어나기 어려움. -> TLS로 만들어진 프로토콜 선택 기능을 사용해 통째로 통신 방식을 전환

* HTTP/2의 목적 : 통신 고속화 

  * 프로토콜 개선 사항 

    * 캐시(max-age) : 통신 자체를 취소 
    * 캐시(Etag, date) : 변경이 없으면 바디 전송을 취소 
    * Keep-alive : 액세스마다 연결에 걸리는 시간을 줄임
    * 압축 : 응답 바디 크기 절감
    * 청크 : 응답 전송 시작을 빠르게 함.
    * 파이프라이닝 : 통신 다중화 

  * 스트림

    * 텍스트 기반에서 바이너리 기반 프로토콜로 변화 

    * 각 데이터는 프레임 단위로 송수신

    * 하나의 TCP접속 안에 스트림이라는 가상의 TCP소켓을 만들어 통신 

    * 프레임에 따른 플래그로 간단히 만들고 닫을 수 있는 규칙으로 되어있음.

      -> TCP소켓과 같은 핸드셰이크 필요없음. 

      -> ID 값과 TCP통신 용량이 허락하는 한 여러 접속을 병렬화 할수 있음.

    * 같은 Stream Identifier를 가진 일련의 프레임은 수신 시에 그룹화 -> 같은 스트림에서 나온 데이터로 취급

    * HTTP/2는 바이너리화 되어 처음에 프레임 크기가 들어감 

      -> TCP소켓 레이어에서는 데이터를 프레임 단위로 쉽게 분리할 수 있음.

      -> 수신 측 TCP 소켓의 버퍼를 빠르게 비울 수 있음.

      -> 통신 상대에게 데이터를 고속으로 요청할 수 있음.

    * 청크와 같은 방식인 것 같으나 요청이 여러개일때 달라짐 

      * HTTP/1.1에서는 청크 형식이라고 해도 하나의 요청 중에 다른 요청 처리할 수 없음
      * HTTP/2에서는 청크가 프레임으로 분할되어 있고 프레임끼리는 독립적이므로, 중간에 다른 프레임이 끼어 들어도 문제 없음. ( 아마 Stream Identifier로 구분하지 않을까.)

  * 플로컨트롤 

    * 스트림을 효율적으로 흐르게 하려고 이용되는 통신량 제어 처리 
    * 통신 속도가 차이 나는 기기의 조합으로 통신할 때 빠른 쪽이 느린 쪽에 대량으로 패킷을 보내버려 처리할 수 없게 되는 사태를 방지

  * 서버푸시 

    * 우선순위가 높은 컨텐츠를 클라이언트가 요구하기 전에 전송할 수 있음

  * HPACK을 이용한 헤더 압축

    * 일반적으로 사용되는 압축 알고리즘과 달리, 사전에 사전을 갖고 있음.
    * 정적 테이블이라는 이름으로 사전에 빈번하게 출현 하는 헤더 이름과 값을 테이블로 가지고 있습니다. 

* Fetch API : 서버 액세스 하는 함수. 

  * XMLHttpRequest보다 오리진 서버 밖으로의 액세스 등 CORS제어가 쉬워진다.
  * 자바스크립트의 모던한 비동기 처리 작성 기법인 프로미스를 따른다.
  * 캐시를 제어할 수 있다.
  * 리다이렉트를 제어할 수 있다.
  * 리퍼러 정책을 설정할 수 있다.
  * Service Worker 내에서 이용할 수 있다. 
    * service worker 
      * 웹이 애플리케이션의 기능성을 지닐 수 있게 하려는 노력으로 애플리케이션의 생애주기와 통신 내용을 제어할 수 있게 하는 기술 
      * 웹 서비스의  프론트엔드 자바스크립트와 서버 사이에서 동작하는 중간 레이어

* Server-sent-events 

  * http5기능 중 하나.
  * 청크 형식을 이용한 통신 기능을 바탕으로 한다.
  * 서버에서 임의의 시점에 클라이언트에 이벤트를 통지할 수 있는 기능 실현.
  * 코멧의 롱폴링과 청크 응답을 조합해 한 번의 요청에 대해서 서버에서 여러 이벤트를 제공

* 웹 소켓 

  * 서버/ 클라이언트 사이에 오버헤드가 적은 양방향 통신을 실현 
  * 프레임 단위로 송수신하지만 상대방이 정해져 있으므로 전송할 곳에 관한 정보는 갖지 않음.
  * http와 다른점 : 스테이트풀 통신 => 메모리에 데이터를 가진 상태로 통신하는 케이스가 많음.
  * 프로토콜 업데이트를 사용함.
    * 우선 시작은 http로 시작하고 그 안에서 프로토콜을 업그레이드해 웹소켓으로 전환.

* WebRTC 

  * 브라우저/ 서버간의 통신뿐만 아니라 브라우저끼리의 P2P통신에도 사용됨.
  * 실시간 커뮤니케이션의 줄임말(RTC)로 실시간 커뮤니케이션을 실현하는 기반으로 설계됨.
  * SDP(세션 기술 프로토콜)
    * P2P니고시에이션 시에 서로의 IP주소와 포트, 양쪽에서 이용할 수 있는 오디오와 동영상 코딩 정보를 공유하기 위한 프로토콜
  * ICE (상호 연결 설정)
    * NAT을 넘어 P2P전송 연결을 설정하는 방법
    * STUN서버 또는 TUN서버를 사용함.

## 8장. HTTP/2의 시맨틱스 : 새로운 활용 사례 

