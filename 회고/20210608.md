# 20210608

## Facts

- 패스트 캠퍼스 자료구조 &알고리즘 강의를 수강했습니다. 
  - 탐욕 알고리즘 
  - 그래프 고급 탐색 알고리즘 : 다익스트라 알고리즘
  - 최소신장트리 : 크루스칼 알고리즘, union-find알고리즘 
- 리얼월드 HTTP 3,4장을 읽고 정리했습니다. 

## Feelings

- 저번주 금요일 부터 밀렸던 자료구조& 알고리즘 강의를 몰아서 들었습니다. 목표를 좀 빡세게 잡았나 싶기도 하지만 한 번 빠르게 훑고 다시 볼 생각으로 공부하고 있습니다. 강의를 다 듣고 한 번 정리할 시간이 어서 왔으면 좋겠습니다. 
- 자료 구조 & 알고리즘 안드로이드 공부를 거의 못하고 있습니다. 조급하게 생각하지 말고 자료구조& 알고리즘 공부가 어느 정도 끝나면 안드로이드를 주로 해서 공부해야겠습니다. 

## Findings

- 알고리즘 

  - 탐욕 알고리즘( Greedy Algorithm )

    - 최적의 해에 가까운 값을 찾기 위해 사용됨.
    - 여러 경우 중 하나를 결정해야할 때마다, 매순간이 최적이라고 생각되는 경우를 선택하는 방식으로 진행해서 최종적인 값을 구하는 방식 

  - 그래프 고급 탐색 알고리즘 

    - 최단 경로 알고리즘 : 두 노드를 잇는 가장 짧은 경로를 찾는 문제 => 가중치 그래프에서 간선의 가중치 합이 최소가 되도록 하는 경로를 찾는 것이 목적.

      - 최단 경로 알고리즘 문제의 종류 
        1. 단일 출발 - 단일 도착 최단 경로 문제 : 특정 노드 u에서 출발, 또 다른 특정 노드 v에 도착하는 가장 짧은 경로를  찾는 문제 
        2. 단일 출발 최단 경로 문제 : 특정 노드 v와 그래프 내 다른 모든 노드 각각의 가장 짧은 경로를 찾는 문제  -> 다익스트라 알고리즘
        3. 전체 쌍 최단 경로 문제 : 그래츠 내의 모든 노드 쌍의(u,v)에 대한 최단 경로를 찾는 문제.

    - 다익스트라 알고리즘 

      - 위의 2번 유형의 문제를 해결하기 위해 사용되는 알고리즘.

      - 첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가면서 최단 거리를 갱신하는 기법

      - 너비 우선 탐색(BFS)과 유사한 방식으로 동작

      - 우선 순위 큐를 활용하여 계산의 양을 줄임. (우선 순위 큐를 사용할 경우 현재 가장 짧은 거리를 항상 먼저 꺼낼 수 있기 때문)

      - 알고리즘 동작 

        1. 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장.
           * 초기에 첫 정점의 거리는 0, 나머지는 무한으로 설정
           * 우선 순위 큐에 첫 정점을 먼저 넣음.
        2. 우선 순위 큐에서 노드를 꺼냄.
           * 처음에는 첫 정점이 꺼내짐.
           * 첫 정점에 인접한 노드들에 대해 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교한다.
           * 배열에 저장되어 있는 거리보다 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우 배열에 해당 노드의 거리를 업데이트한다.
           * 배열에 해당 노드의 거리가 업데이트 된 경우, 우선 순위 큐에 넣는다.
             * 결과적으로 너비 우선 탐색과 유사하게, 첫 정점에 인접한 노드들을 순차적으로 방문하게 됨.
             * 거리가 먼 애들은 우선 순위가 밀려나게 됨.
        3. 2번의 과정을 우선 순위 큐에서 꺼낼 노드가 없을 때까지 반복.

      - 시간 복잡도 : O(E log E)

        - 과정을 나눠서 계산 

        - 과정 1 : 각 노드를 최대 한 번씩 방문 O(E)

          => 그래프의 모든 간선은 최대 한 번씩 검사.

          => 각 노드마다 인접한 간선들을 모두 검사하는 과정 : O(E)

        - 과정 2: O(E log E)

          => 우선 순위 큐에 데이터를 넣는 순간이 최악의 경우 매 실행시 마다 큐에 데이터를 넣을 수 있음 : O(E)

          => 우선 순위 큐를 유지하는 작업 : O(log E)

        - 과정 1  O(E)  + 과정 2 O(E log E)

    - 최소 신장 트리 

      - 신장 트리와 최소 신장 트리 

        - 신장 트리 (Spanning Tree) : 원래의 그래프의 모든 노드가 연결되어 있으면서 트리의 속성을 만족하는 그래프 
          - 신장 트리의 조건 
            1. 본래 그래프의 모든 노드를 포함해야 한다.
            2. 모든 노드가 서로 연결
            3. 트리의 속성을 만족(싸이클이 존재하지 않는다.)
        - 최소 신장 트리(Minimum Spanning Tree, MST) : 가능한 spanning tree 중에서 간선의 가중치 합이 최소인 spanning tree

      - 최소 신장 트리 알고리즘 : 그래프에서 최소 신장 트리를 찾을 수 있는 알고리즘(크루스칼 알고리즘, 프림 알고리즘)

        - 크루스칼 알고리즘 

          1. 모든 정점을 독립적인 집합으로 만든다.
          2. 모든 간선을 비용 기준으로 정렬하고, 비용이 적은 간선부터 양 끝의 두 정점을 비교한다.
          3. 두 정점의 최상위 정점(루트 노드)을 확인하고, 서로 다를 경우 두 정점을 연결한다.(싸이클이 생기지 않도록 하기 위해 루트 노드를 확인)

        - 어떻게 싸이클 여부를 확인할 것인가 ? => Union-Find 알고리즘 사용. 

        - Union-Find 알고리즘

          - 여러개의 부분 집합(중복 노드가 없는) 끼리 합치거나 연결 했을 때 싸이클 여부를 판단할 수 있는 알고리즘.

          - Disjoint set을 표현할 때 사용하는 알고리즘으로 트리 구조를 활용하는 알고리즘.

            * Disjoint set : 서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조. (= 서로소 집합.)

          - 과정 

            - Union : 두 개의 부분 집합을 합치는 과정 (집합은 트리 구조로 표현)
            - Find : 현재 두 노드가 같은 집합에 있는지 없는지 판단하는 과정(루트 노드를 비교해서)

          - Union-Find알고리즘의 고려할 점.

            - 루트 노드를 어떻게 찾는냐, 트리를 어떻게 구성하느냐에 따라 알고리즘의 성능이 달라짐
            - union순서에 따라 최악의 경우 링크드 리스트와 같은 형태가 될 수 있음.
            - 문제를 해결하기 위해 union by rank, path compression기법을 사용함. => 시간 복잡도를 줄일 수 있음.( O(M log * N) = O(1) )

          - Union by rank :

            -  각 트리에 대한 높이(rank)를 기억해 두고, union시 
              - 두 집합의 rank가 다른 경우 : rank가 작은 트리를 rank가 높은 트리에 붙임.
              - 두 집합의 rank가 같은 경우 : 한 집합의 rank를 1올려주고 다른 집합을 1증가된 트리에 붙임.
            - 루트 노드를 찾는데 O(log N)으로 시간 복잡도를 낮출 수 있다.

          - Path compression : 

            - find를 실행한 노드에서 거쳐간 노드를 루트에 다이렉트로 연결하는 기법

              => find를 실행한 이후 부터는 루트 노드를 한 번에 알수 있음.

## Future Action Plans

* 자료구조 & 알고리즘 이론 강의를 완강하겠습니다. 
* 리얼월드 Http 스터디 준비

